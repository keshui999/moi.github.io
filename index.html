<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>äº”å­æ£‹è·¨è®¾å¤‡è”æœº</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: sans-serif; }
        body { background: linear-gradient(135deg, #f5f7fa, #c3cfe2); min-height: 100vh; padding: 15px; }
        .page { display: none; max-width: 400px; margin: 0 auto; }
        .page.active { display: block; }
        .start-page { text-align: center; background: #fff; border-radius: 20px; padding: 30px 25px; box-shadow: 0 8px 24px rgba(0,0,0,0.08); }
        .start-page h1 { font-size: 28px; margin-bottom: 20px; color: #2d3748; }
        .start-page input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; margin-bottom: 15px; text-align: center; }
        .btn { display: block; width: 100%; padding: 14px; border: none; border-radius: 12px; font-size: 16px; font-weight: 500; cursor: pointer; color: #fff; margin-bottom: 10px; }
        .host-btn { background-color: #4299e1; }
        .guest-btn { background-color: #48bb78; }
        .board-page { text-align: center; }
        .board-header { background: #fff; border-radius: 16px; padding: 15px; margin-bottom: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.06); }
        .game-status { font-size: 15px; color: #4a5568; }
        .chess-board { position: relative; background-color: #e9d8a6; border: 3px solid #b98f5e; border-radius: 8px; aspect-ratio: 1/1; width: 100%; display: grid; grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(15, 1fr); margin-bottom: 15px; }
        .chess-board::before { content: ""; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-image: linear-gradient(to right, #5c4033 1px, transparent 1px), linear-gradient(to bottom, #5c4033 1px, transparent 1px); background-size: calc(100% / 15); z-index: 1; margin: 1px; }
        .star { position: absolute; width: 6px; height: 6px; background-color: #5c4033; border-radius: 50%; z-index: 5; }
        .star.center { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .star.tl { top: calc(100% * 4 / 14); left: calc(100% * 4 / 14); }
        .star.tr { top: calc(100% * 4 / 14); left: calc(100% * 10 / 14); }
        .star.bl { top: calc(100% * 10 / 14); left: calc(100% * 4 / 14); }
        .star.br { top: calc(100% * 10 / 14); left: calc(100% * 10 / 14); }
        .intersection { width: 22px; height: 22px; border-radius: 50%; justify-self: center; align-self: center; z-index: 10; cursor: pointer; }
        .intersection:hover:not(.black):not(.white) { background-color: rgba(92, 64, 51, 0.15); }
        .intersection.black, .intersection.white { position: relative; }
        .intersection.black::after, .intersection.white::after { content: ""; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 80%; height: 80%; border-radius: 50%; animation: placeStone 0.2s ease-out; }
        .intersection.black::after { background: radial-gradient(circle at 35% 35%, #555, #000); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .intersection.white::after { background: radial-gradient(circle at 35% 35%, #fff, #d0d0d0); box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        @keyframes placeStone { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 80% { transform: translate(-50%, -50%) scale(1.05); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
        .play-again-btn { background-color: #4299e1; display: none; margin: 0 auto; width: 80%; }
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); color: #fff; padding: 8px 15px; border-radius: 6px; font-size: 14px; opacity: 0; pointer-events: none; transition: opacity 0.2s; z-index: 1001; }
        .toast.active { opacity: 1; pointer-events: all; }
    </style>
</head>
<body>
    <div class="page start-page active" id="startPage">
        <h1>äº”å­æ£‹è·¨è®¾å¤‡è”æœº</h1>
        <input type="text" id="roomIdInput" placeholder="è¾“å…¥ä»»æ„æˆ¿é—´å·ï¼ˆå¦‚123ï¼‰" maxlength="6">
        <button class="btn host-btn" id="joinBtn">åŠ å…¥æˆ¿é—´</button>
    </div>

    <div class="page board-page" id="boardPage">
        <div class="board-header">
            <div class="game-status" id="gameStatus">ç­‰å¾…å¯¹æ‰‹åŠ å…¥...</div>
        </div>
        <div class="chess-board" id="chessBoard">
            <div class="star center"></div>
            <div class="star tl"></div>
            <div class="star tr"></div>
            <div class="star bl"></div>
            <div class="star br"></div>
        </div>
        <button class="btn play-again-btn" id="playAgainBtn">å†æ¥ä¸€å±€</button>
    </div>

    <div class="toast" id="toast">æç¤º</div>

    <script>
        // å…è´¹å…¬å…±WebSocketä¸­ç»§æœåŠ¡ï¼ˆæ— éœ€æ­å»ºæœåŠ¡å™¨ï¼‰
        const WS_URL = 'wss://echo.websocket.events/';
        let ws;
        let roomId = '';
        let myColor = ''; // black/white
        let isMyTurn = false;
        let gameOver = false;
        let board = Array(15).fill().map(() => Array(15).fill(null));
        let players = new Set(); // æˆ¿é—´å†…ç©å®¶ID

        // DOMå…ƒç´ 
        const startPage = document.getElementById('startPage');
        const boardPage = document.getElementById('boardPage');
        const roomIdInput = document.getElementById('roomIdInput');
        const joinBtn = document.getElementById('joinBtn');
        const gameStatus = document.getElementById('gameStatus');
        const chessBoard = document.getElementById('chessBoard');
        const playAgainBtn = document.getElementById('playAgainBtn');
        const toast = document.getElementById('toast');

        // åˆå§‹åŒ–WebSocket
        function initWS() {
            ws = new WebSocket(WS_URL);
            ws.onopen = () => {
                showToast('è”æœºé€šé“å·²è¿æ¥');
                sendMsg({ type: 'join', roomId });
            };
            ws.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    handleWSMessage(data);
                } catch (err) {}
            };
            ws.onclose = () => {
                showToast('è”æœºé€šé“å·²æ–­å¼€ï¼Œæ­£åœ¨é‡è¿...');
                setTimeout(initWS, 3000);
            };
            ws.onerror = (err) => {
                showToast('è”æœºå‡ºé”™ï¼š' + err.message);
            };
        }

        // å¤„ç†WebSocketæ¶ˆæ¯
        function handleWSMessage(data) {
            if (data.roomId !== roomId) return; // åªå¤„ç†å½“å‰æˆ¿é—´æ¶ˆæ¯

            switch (data.type) {
                case 'join':
                    players.add(data.playerId);
                    if (players.size === 1) {
                        myColor = 'black';
                        isMyTurn = true;
                        updateGameStatus('ä½ æ˜¯é»‘æ–¹ï¼Œç­‰å¾…å¯¹æ‰‹åŠ å…¥');
                    } else if (players.size === 2) {
                        myColor = 'white';
                        isMyTurn = false;
                        updateGameStatus('ä½ æ˜¯ç™½æ–¹ï¼Œç­‰å¾…é»‘æ–¹è½å­');
                        sendMsg({ type: 'start' });
                    }
                    break;
                case 'start':
                    if (myColor === 'black') updateGameStatus('ä½ æ˜¯é»‘æ–¹ï¼Œè¯¥ä½ è½å­');
                    break;
                case 'move':
                    board[data.i][data.j] = data.color;
                    renderBoard();
                    const winner = checkWin(data.i, data.j);
                    if (winner) {
                        gameOver = true;
                        updateGameStatus(`ğŸ‰ ${winner === 'black' ? 'é»‘æ–¹' : 'ç™½æ–¹'}è·èƒœï¼`);
                        playAgainBtn.style.display = 'block';
                        showToast(`${winner === 'black' ? 'é»‘æ–¹' : 'ç™½æ–¹'}è·èƒœï¼`);
                    } else if (checkDraw()) {
                        gameOver = true;
                        updateGameStatus('ğŸ¤ æ¸¸æˆå¹³å±€ï¼');
                        playAgainBtn.style.display = 'block';
                        showToast('æ¸¸æˆå¹³å±€');
                    } else {
                        isMyTurn = data.color !== myColor;
                        updateGameStatus(isMyTurn ? `è¯¥ä½ è½å­ï¼ˆ${myColor === 'black' ? 'é»‘æ–¹' : 'ç™½æ–¹'}ï¼‰` : 'ç­‰å¾…å¯¹æ‰‹è½å­...');
                    }
                    break;
                case 'restart':
                    board = Array(15).fill().map(() => Array(15).fill(null));
                    gameOver = false;
                    playAgainBtn.style.display = 'none';
                    isMyTurn = myColor === 'black';
                    updateGameStatus(isMyTurn ? `è¯¥ä½ è½å­ï¼ˆ${myColor === 'black' ? 'é»‘æ–¹' : 'ç™½æ–¹'}ï¼‰` : 'ç­‰å¾…å¯¹æ‰‹è½å­...');
                    renderBoard();
                    break;
            }
        }

        // å‘é€æ¶ˆæ¯
        function sendMsg(data) {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const msg = {
                ...data,
                roomId,
                playerId: Math.random().toString(36).substr(2, 9) // éšæœºç©å®¶ID
            };
            ws.send(JSON.stringify(msg));
        }

        // åŠ å…¥æˆ¿é—´
        function joinRoom() {
            roomId = roomIdInput.value.trim();
            if (!roomId) {
                showToast('è¯·è¾“å…¥æˆ¿é—´å·');
                return;
            }
            startPage.classList.remove('active');
            boardPage.classList.add('active');
            initBoard();
            initWS();
        }

        // å¤„ç†è½å­
        function handleCellClick(e) {
            if (!isMyTurn || gameOver || !ws) return;
            const i = parseInt(e.target.dataset.i);
            const j = parseInt(e.target.dataset.j);
            if (board[i][j] !== null) return;

            const color = myColor;
            sendMsg({ type: 'move', i, j, color });
        }

        // åˆå§‹åŒ–æ£‹ç›˜
        function initBoard() {
            chessBoard.innerHTML = '';
            ['center', 'tl', 'tr', 'bl', 'br'].forEach(cls => {
                const star = document.createElement('div');
                star.className = `star ${cls}`;
                chessBoard.appendChild(star);
            });
            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    const intersection = document.createElement('div');
                    intersection.className = 'intersection';
                    intersection.dataset.i = i;
                    intersection.dataset.j = j;
                    intersection.addEventListener('click', handleCellClick);
                    chessBoard.appendChild(intersection);
                }
            }
            renderBoard();
        }

        // æ¸²æŸ“æ£‹ç›˜
        function renderBoard() {
            document.querySelectorAll('.intersection').forEach(cell => {
                cell.classList.remove('black', 'white');
            });
            for (let i = 0; i < 15; i++) {
                for (let j = 0; j < 15; j++) {
                    const color = board[i][j];
                    if (color) {
                        const cell = document.querySelector(`.intersection[data-i="${i}"][data-j="${j}"]`);
                        cell.classList.add(color);
                    }
                }
            }
        }

        // èƒœè´Ÿåˆ¤æ–­
        function checkWin(x, y) {
            const color = board[x][y];
            const dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[1,1],[-1,1],[1,-1]];
            const checkDir = (dx, dy) => {
                let count = 1;
                let nx = x + dx, ny = y + dy;
                while (nx >=0 && nx <15 && ny >=0 && ny <15 && board[nx][ny] === color) { count++; nx += dx; ny += dy; }
                nx = x - dx, ny = y - dy;
                while (nx >=0 && nx <15 && ny >=0 && ny <15 && board[nx][ny] === color) { count++; nx -= dx; ny -= dy; }
                return count >= 5;
            };
            for (let d = 0; d < dirs.length; d += 2) {
                if (checkDir(dirs[d][0], dirs[d][1])) return color;
            }
            return null;
        }

        // å¹³å±€åˆ¤æ–­
        function checkDraw() {
            for (let i = 0; i < 15; i++) for (let j = 0; j < 15; j++) if (!board[i][j]) return false;
            return true;
        }

        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function updateGameStatus(text) {
            gameStatus.textContent = text;
        }

        // æç¤ºå¼¹çª—
        function showToast(text) {
            toast.textContent = text;
            toast.classList.add('active');
            setTimeout(() => toast.classList.remove('active'), 2000);
        }

        // å†æ¥ä¸€å±€
        playAgainBtn.addEventListener('click', () => {
            sendMsg({ type: 'restart' });
        });

        // ç»‘å®šäº‹ä»¶
        joinBtn.addEventListener('click', joinRoom);

        // é˜»æ­¢ä¸‹æ‹‰åˆ·æ–°
        document.addEventListener('touchmove', (e) => {
            if (e.target === chessBoard) e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>